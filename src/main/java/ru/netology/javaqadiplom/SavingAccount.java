package ru.netology.javaqadiplom;

/**
 * Сберегательный счёт
 * Может иметь баланс только в пределах от указанного минимального до указанного максимального включительно.
 * Не может уходить в минус (минимальный баланс не может быть отрицательным).
 * Имеет ставку - количество процентов годовых на остаток.
 */
public class SavingAccount extends Account {
    protected int minBalance;
    protected int maxBalance;

    /**
     * Создаёт новый объект сберегательного счёта с заданными параметрами.
     * Если параметры некорректны (мин. баланс больше максимального и так далее), то
     * должно выкидываться исключения вида IllegalArgumentException.
     * @param initialBalance - начальный баланс
     * @param minBalance - минимальный баланс
     * @param maxBalance - максимальный баланс
     * @param rate - неотрицательное число, ставка в процентах годовых на остаток
     */
    public SavingAccount(int initialBalance, int minBalance, int maxBalance, int rate) {
        if (rate < 0) {
            throw new IllegalArgumentException(
              "Накопительная ставка не может быть отрицательной, а у вас: " + rate
            );
        }
        this.balance = initialBalance;
        this.minBalance = minBalance;
        this.maxBalance = maxBalance;
        this.rate = rate;
    }
    // Алексей Уткин: в конструкторе отсутствуют исключения для параметров. По условиям
    // необходим выброс IllegalArgumentException, если "параметры некорректны (мин. баланс
    // больше максимального и так далее)", то есть нужны эксепшены для мин>макс, мин<0,
    // начальный<мин и >макс.

    /**
     * Операция оплаты с карты на указанную сумму.
     * В результате успешного вызова этого метода, баланс должен уменьшиться
     * на сумму покупки. Если же операция может привести к некорректному
     * состоянию счёта (например, баланс может уйти в минус), то операция должна
     * завершиться вернув false и ничего не поменяв на счёте.
     * @param amount - сумма покупки
     * @return true если операция прошла успешно, false иначе.
     */
    @Override
    public boolean pay(int amount) {
        if (amount <= 0) {
            return false;
        }
        balance = balance - amount;
        if (balance > minBalance) {
            return true;
        } else {
            return false;
        }
    }
    // Алексей Уткин: отсутствует проверка "(баланс - платёж) <= мин. баланс" до совершения
    // операции. Проверка "если баланс > мин. баланса", совершаемая уже после операции,
    // противоречит логике. Также остаток после платежа должен быть не >, а >= мин.

    /**
     * Операция пополнения карты на указанную сумму.
     * В результате успешного вызова этого метода, баланс должен увеличиться
     * на сумму покупки. Если же операция может привести к некорректному
     * состоянию счёта, то операция должна
     * завершиться вернув false и ничего не поменяв на счёте.
     * @param amount - сумма пополнения
     * @return true если операция прошла успешно, false иначе.
     * @param amount
     * @return
     */
    @Override
    public boolean add(int amount) {
        if (amount <= 0) {
            return false;
        }
        if (balance + amount < maxBalance) {
            balance = amount;
            return true;
        } else {
            return false;
        }
    }
    // Алексей Уткин: некорректная проверка "если (баланс + пополнение) < макс. баланса, так
    // как (баланс + пополнение) могут быть равны макс. балансу. Также в условии "то" баланс
    // равен пополнению, в то время как баланс должен быть равен (баланс + пополнение).

    /**
     * Операция расчёта процентов на остаток счёта при условии, что
     * счёт не будет меняться год. Сумма процентов приводится к целому
     * числу через отбрасывание дробной части (так и работает целочисленное деление).
     * Пример: если на счёте 200 рублей, то при ставке 15% ответ должен быть 30.
     * @return
     */
    @Override
    public int yearChange() {
        return balance / 100 * rate;
    }
    // некорректная реализация метода нарушает бизнес-логику: если сначала разделить на 100,
    // а только потом умножить на ставку. В противном случае клиент теряет деньги, потому как
    // теряется разница между, например, 200 и 299 рублями на счёте.

    public int getMinBalance() {
        return minBalance;
    }

    public int getMaxBalance() {
        return maxBalance;
    }
}
